<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://galiful.github.io/Resume/</id>
    <title>Galiful</title>
    <updated>2019-06-12T05:17:23.645Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://galiful.github.io/Resume/"/>
    <link rel="self" href="https://galiful.github.io/Resume//atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://galiful.github.io/Resume//images/avatar.png</logo>
    <icon>https://galiful.github.io/Resume//favicon.ico</icon>
    <rights>All rights reserved 2019, Galiful</rights>
    <entry>
        <title type="html"><![CDATA[Handler类中发送消息-post()和postDelay()方法]]></title>
        <id>https://galiful.github.io/Resume//post/handler-lei-zhong-fa-song-xiao-xi-posthe-postdelayfang-fa</id>
        <link href="https://galiful.github.io/Resume//post/handler-lei-zhong-fa-song-xiao-xi-posthe-postdelayfang-fa">
        </link>
        <updated>2019-06-10T09:49:27.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://img-blog.csdn.net/20180326181513374?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTEwMTE3Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="">
<img src="https://img-blog.csdn.net/20180326181526567?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTEwMTE3Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="">
首先，post和postDelay都是Handler的方法，用以在子线程中发送Runnable对象的方法；</p>
<p>其次，Android中post()方法可以直接在非UI线程中更新UI，不同与Handelr的Send类方法，需要进行切换；</p>
<p>最后，两个方法在实现UI线程事件的时间上有所区别，postDelayed()方法用以延期执行，post则是立即执行。
// 三种切回主线程更新UI的方法<br>
```
imageView.post(new Runnable() {
@Override
public void run() {
imageView.setImageBitmap(bitmap1); // 素描图
}
});</p>
<pre><code>            runOnUiThread(new Runnable() {
                @Override
                public void run() {
                    orignView.setImageBitmap(bitmap2); // 素描图
                }
            });

            handler.post(new Runnable() {
                @Override
                public void run() {
                    threeView.setImageBitmap(bitmap3); // 素描图
                }
            });
</code></pre>
<pre><code>  
send方法：  

private Handler handler = new Handler(){
    @Override
    public void handleMessage(Message msg) {
        super.handleMessage(msg);
        switch (msg.what) {      //判断标志位
            case 1:
                /**
                 获取数据，更新UI
                */
                break;
        }
    }
};
   
 
public class WorkThread extends Thread {
 
    @Override
    public void run() {
        super.run();
       /**
         耗时操作
        */
  
        //从全局池中返回一个message实例，避免多次创建message（如new Message）
        Message msg =Message.obtain();  
        msg.obj = data;
        msg.what=1;   //标志消息的标志
        handler.sendMessage(msg);
    } 
}




</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[两种Activity的生命周期及Camera资源的释放]]></title>
        <id>https://galiful.github.io/Resume//post/liang-chong-activity-de-sheng-ming-zhou-qi-ji-camera-zi-yuan-de-shi-fang</id>
        <link href="https://galiful.github.io/Resume//post/liang-chong-activity-de-sheng-ming-zhou-qi-ji-camera-zi-yuan-de-shi-fang">
        </link>
        <updated>2019-06-10T00:03:10.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>在一次项目中尝试使用DialogActivity（对话框式活动）时又恰巧调用了摄像头，有oneActivity（普通活动）和twoActivity（对话框式活动），两个活动均使用了摄像头，oneActivity跳转到twoActivity时，即使做了资源释放，跳转时twoActivity摄像头正常，但back回oneActivity时，oneActivity摄像头异常（画面不动），按home后（执行onResume）后正常，可刚刚按back时执行了onResume了的。可当twoActivity为普通活动时，又一切正常~~~</p>
</blockquote>
<h3 id="再次认识活动的生命周期">再次认识活动的生命周期</h3>
<p>一 返回栈<br>
1.定义： Android是使用任务（Task）来管理活动的，一个任务就是一组存放在栈里的活动 的集合这个栈也被称作返回栈（Back Stack）。
2.栈顶：存放刚启动的一个新的活动。（当我们 按下 Back键或调用 finish()方法去销毁一个活动时，处于栈顶的活动会出栈，这时前一个入 栈的活动就会重新处于栈顶的位置。系统总是会显示处于栈顶的活动给用户。）</p>
<p>二 活动状态<br>
1.运行状态：活动位于返回栈的栈顶时（系统最不愿意回收的 就是处于运行状态的活动，因为这会带来非常差的用户体验。）</p>
<p>2.暂停状态：当一个活动不再处于栈顶位置，但仍然可见时（比如某个活动上面新开了个对话框活动该活动就是暂停活动-系统也不愿意去回收这 种活动。）</p>
<p>3.停止状态：当一个活动不再处于栈顶位置，并且完全不可见的时候，就进入了停止状态。（系统 仍然会为这种活动保存相应的状态和成员变量，但很容易被回收）</p>
<p>4.销毁状态：当一个活动从返回栈中移除后就变成了销毁状态（系统会最倾向于回收处于这种状 态的活动，从而保证手机的内存充足。）</p>
<p>三 创建活动的生存期<br>
1.onCreate()：它会在活动 第一次被创建的时候调用用于加载布局、绑定事件等。</p>
<p>2.onStart()：这个方法在活动由不可见变为可见的时候调用。</p>
<p>3.onResume()：这个方法在活动准备好和用户进行交互的时候调用。此时的活动一定位于返回栈的 栈顶，并且处于运行状态。</p>
<p>4.onPause()： 这个方法在系统准备去启动或者恢复另一个活动的时候调用。</p>
<p>5.onStop()：  这个方法在活动完全不可见的时候调用。-----（如 果启动的新活动是一个对话框式的活动，那么 onPause()方法会得到执行，而 onStop() 方法并不会执行。）。</p>
<p>6.onDestroy()：这个方法在活动被销毁之前调用，之后活动的状态将变为销毁状态。</p>
<p>7.onRestart()：活动被重新启动时调用。</p>
<p><strong>完整生存期</strong>：【 onCreate()~ onDestroy()】之间。<br>
<strong>可见生存期</strong>：【 onStart()~ onStop()】之间。活动对于用户总是可见的！（我们可以通过这两个方法对资源进行加载和释放）<br>
<strong>前台生存期</strong>：【 onResume()~ onPause()】之间。活动总是处于运行状态的！（可以和用户进行相互。）</p>
<h3 id="演绎">演绎</h3>
<p>重温以上知识点后重新演绎上述场景，<br>
<strong>twoActivity为正常活动时</strong>：<br>
MainActivity   执行：
onCreate()<br>
onStart()<br>
onResume() 方法<br>
然后点击第一个按钮启动 NormalActivity：（由于 NormalActivity已经把 MainActivity完全遮挡住，）<br>
执行：
onPause()<br>
onStop()<br>
然后按下 Back键返回 MainActivity（由于之前 MainActivity已经进入了停止状态）<br>
执行：<br>
onRestart()<br>
onStart()<br>
onResume()</p>
<p><strong>twoActivity为对话框活动时</strong>：<br>
然后再点击第二个按钮，启动 DialogActivity（DialogActivity并没有完全遮挡住 MainActivity）<br>
执行：<br>
onPause()<br>
Back键返回 MainActivity<br>
执行：<br>
onResume()<br>
最后在 MainActivity按下 Back键退出程序<br>
执行：<br>
onPause()<br>
onStop()<br>
onDestroy()</p>
<p><strong>结论</strong>：<strong>dialogActivity不会执行onStop、onRestart()、 onStart()</strong>，导致相机资源没有正常回调（也许可以通过修改相机类修复）<br>
下面是项目中（asrDemo→DetectLoginActivity）生命周期log：
<img src="https://galiful.github.io/Resume//post-images/1560134889431.png" alt="">
可见在这台设备上，在执行AsrDemo onPause后就执行了DetectLoginActivity onCreate，如果没有合理释放资源必然出现占用错误（camera can not connect 等...）<br>
当DetectLoginActivity为对话框式活动时生命周期log：
<img src="https://galiful.github.io/Resume//post-images/1560134787747.png" alt="">
<strong>这次跳转过程asrDemo中camera并没有回调发生</strong><br>
在asrDemo、DetectLoginActivity中camera释放放在onPause()，以在asrDemo跳转和DetectLoginActivity back时释放。</p>
<h3 id="小结">小结</h3>
<p>关于如何解决在有camera活动打开另一个camera活动，且第二个又是DialogActivity，中的camera正常调用问题?
本次项目做法是将第二个活动改为普通活动（黑线~）
有大佬说可以把dialogActivity改为<strong>DialogFragment</strong>，生命周期就正常了，自己做了尝试，跟继承Dialog类似，由于项目设计代码较多且是引用的，半途中止，先实现功能再说，后面自己写时尝试再使用DialogFragment看看效果</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于application的继承]]></title>
        <id>https://galiful.github.io/Resume//post/guan-yu-application-de-ji-cheng</id>
        <link href="https://galiful.github.io/Resume//post/guan-yu-application-de-ji-cheng">
        </link>
        <updated>2019-06-04T00:01:53.000Z</updated>
        <content type="html"><![CDATA[<h2 id="记一次集成百度facesdk中遇到的知识盲点">记一次集成百度facesdk中遇到的知识盲点。</h2>
<p>一些app通过继承application作为 应用程序入口调用，避免手机内存过小,杀死后台进程（在手机设置里面，对应于某一个应用，虽然没有启动，但是上面有一个终止按钮，说明这个应用时启动的，只是里面没有Activity,所以说使用android退出把一个应用退出，实际上他所对应的Application是没有退出的（因为他的生命周期最长），只是对应的Activity退出了而已）</p>
<h3 id="认识application">认识application：</h3>
<p>android开发文档中关于application的描述 :
Base class for those who need to maintain global application state. You can provide your own implementation by specifying its name in your AndroidManifest.xml's &lt; application&gt; tag, which will cause that class to be instantiated for you when the process for your application/package is created.</p>
<h4 id="application-配置全局context">Application 配置全局Context</h4>
<p>第一步、写一个全局的单例模式的MyApplication继承自Application 覆盖onCreate ，在这个方法里面实例化Application,并且值是全局的,可以使用Context的 getApplicationContext或者Activity的getApplication方法来获得一个application对象来拿到它。</p>
<ol>
<li>
<p>oncreate方法
application对应的也有一个onCreate,这个才是真正的入口，不过一般我们使用的是Activity的onCreate方法作为入口使用了。
<em>开发文档描述</em>：
* Called when the application is starting, before any other application
* objects have been created.  Implementations should be as quick as
* possible (for example using lazy initialization of state) since the time
* spent in this function directly impacts the performance of starting the
* first activity, service, or receiver in a process.
* If you override this method, be sure to call super.onCreate()</p>
</li>
<li>
<p>onConfigurationChanged方法
当屏幕方向发生改变了，就会调用这个方法，并且对应的Activity中也会调用对应的方法
因此不必再次处理</p>
</li>
</ol>
<p>第二步、配置全局的Context
<code>&lt;application android:name=&quot;com.example.demo.MyApplication&quot; &gt;&lt;/application&gt;</code></p>
<p>第三步、使用的时候用的时候根据类的名称访问Context，manifest文件<application>有一项是android:name属性，一般你新建一个android项目的话，这个name属性是没有的，如果想要使用自定义的MyApplication的话，就要添加上一个name属性，如上面显示的那样，然后自定义一个类：MyApplication来继承application即可</p>
<h4 id="android程序的入口点">Android程序的入口点</h4>
<p>Android使用Google Dalvik VM，相对于传统Java VM而言有着很大的不同，在Sun的Java体系中入口点和标准c语言一样是main()，而每个Android程序都包含着一个Application实例，一个Application实例中有多个Activity、Service、ContentProvider或Broadcast Receiver。因为大部分的应用都包含Activity所以，说很多网友认为是Activity的onCreate，但是你没有发现你的工程中有多个Activity吗? 你可能没有见过没有Activity的Android应用吧。其实在android.app.Application这个包的onCreate才是真正的Android入口点，只不过大多数开发者无需重写该类，他的继承关系如下图:</p>
<p>java.lang.Object
? android.content.Context
? android.content.ContextWrapper
? android.app.Application</p>
<p>android.app.Application类包含了4个公开的方法</p>
<p>void  onConfigurationChanged(Configuration newConfig)
void  onCreate()  //这里才是真正的入口点。
void  onLowMemory()
void  onTerminate()</p>
<p>所以希望大家，记住真正的Android入口点是application的main，你可以看下androidmanifest.xml的包含关系就清楚了，并不是每个应用都必须有Activity的。</p>
<pre><code>问题一：
在这次集成中，原项目和facesdk 都使用application继承类作为程序入口初始化，知道这个后：
</code></pre>
<h4 id="android中两个application该如何继承和声明">Android中两个application该如何继承和声明？</h4>
<pre><code>1.继承：假如你有两个application类：ApplicationOne.java和ApplicationTwo.java
</code></pre>
<p>ApplicationOne才是你真正的程序入口，ApplicationTwo是第三方sdk或库里定义的，那么你可以把ApplicationOne继承于ApplicationTwo。</p>
<p>2.声明：在AndroidManifest.xml里声明的时候，只需要声明ApplicationOne就行了。因为AndroidManifest.xml中第一个注册的Application才真正会被PackageManager解析，才是有效的。
<img src="https://galiful.github.io/Resume//post-images/1559609327818.png" alt="">
详见：<a href="https://developer.android.google.cn/reference/android/app/Application?hl=en">Application  |  Android Developers</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[EasyPermissions的使用]]></title>
        <id>https://galiful.github.io/Resume//post/easypermissions-de-shi-yong</id>
        <link href="https://galiful.github.io/Resume//post/easypermissions-de-shi-yong">
        </link>
        <updated>2019-05-27T01:58:26.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://segmentfault.com/a/1190000012247350">https://segmentfault.com/a/1190000012247350</a></p>
<p>GitHub地址：https://github.com/googlesamp...
EasyPermissions是谷歌封装的一个运行时权限申请的库，简化了操作的过程。
使用过程： 没有什么先后顺序，下面没有按这个顺序。这么做是可以的，当然还有其他的使用方法</p>
<blockquote>
<p>1、builde gradle中依赖
2、清单文件中声明权限
3、重写onRequestPermissionsResult()方法，把执行操作给easyPermissions来
4、通过hasPermissions检查权限，或者原生的也行，然后去申请权限
5、实现EasyPermissions.PermissionCallbacks接口，重写两个方法，成功或失败
6、在成功或者失败方法中编写要具体做的事。</p>
</blockquote>
<h3 id="github地址">GitHub地址：</h3>
<p>(1)依赖库</p>
<pre><code>dependencies {
    compile 'pub.devrel:easypermissions:1.0.1'
}
</code></pre>
<p>(2)再在清单文件中声明要申请的危险权限
如果不声明的话，直接在代码中写也能申请成功，但是好想不会弹出询问框，直接就申请了</p>
<p>(3)申请权限
可以直接申请</p>
<pre><code>EasyPermissions.requestPermissions(
                    MainActivity.this,
                    &quot;申请权限&quot;,
                    0,
                    Manifest.permission.WRITE_EXTERNAL_STORAGE,
                    Manifest.permission.RECORD_AUDIO);
</code></pre>
<p>最好还是检查一下权限是否申请：
EasyPermissions.hasPermissions(Context context, @NonNull String… perms)方法来检测一个或者多个权限是否被允许，第二个参数是个可变数组，可以申请多个</p>
<pre><code>String[] perms = {Manifest.permission.CAMERA, Manifest.permission.ACCESS_FINE_LOCATION};
if (EasyPermissions.hasPermissions(this, perms)) {
    
    // 已经申请过权限，做想做的事
} else {
    // 没有申请过权限，现在去申请
    EasyPermissions.requestPermissions(this, getString(R.string.camera_and_location_rationale),
            RC_CAMERA_AND_LOCATION, perms);
}
</code></pre>
<p>下面来说一个申请权限这个方法：
EasyPermissions.requestPermissions():
requestPermissions() 一般用这个四个参数的就可以
第一个参数：Context对象
第二个参数：权限弹窗上的文字提示语。告诉用户，这个权限用途。
第三个参数：这次请求权限的唯一标识请求码，code。
第四个参数 : 一些系列的权限。
这里说一下第二个参数，不是第一次申请系统默认弹出的提示语，而是，我们拒绝后，再次点击申请弹出的对话框，，显示我们设置的提示语，下面有两个按钮，确认和取消，我就不贴图了。</p>
<p>还有六个参数的，多了两个参数就是，修改我们上面那个确认和取消的字样，你可以干成yes 和no.</p>
<h3 id="4-重写onrequestpermissionsresult方法把执行操作给easypermissions">4、重写onRequestPermissionsResult()方法，把执行操作给easyPermissions</h3>
<p>一行代码就搞定了</p>
<pre><code> @Override
public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
    super.onRequestPermissionsResult(requestCode, permissions, grantResults);
    EasyPermissions.onRequestPermissionsResult(requestCode, permissions, grantResults, this);
}
</code></pre>
<p>5、实现EasyPermissions.PermissionCallbacks接口，重写两个方法</p>
<pre><code>public class MainActivity extends AppCompatActivity implements EasyPermissions.PermissionCallbacks {

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
}

@Override
public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
    super.onRequestPermissionsResult(requestCode, permissions, grantResults);

    // 把执行结果的操作给EasyPermissions
    EasyPermissions.onRequestPermissionsResult(requestCode, permissions, grantResults, this);
}

@Override //申请成功时调用
public void onPermissionsGranted(int requestCode, List&lt;String&gt; list) {
    //请求成功执行相应的操作
    
    比如，举个例子
    switch (requestCode){
        case 0:
            Toast.makeText(this, &quot;已获取WRITE_EXTERNAL_STORAGE权限&quot;, Toast.LENGTH_SHORT).show();
            break;
        case 1:
            Toast.makeText(this, &quot;已获取WRITE_EXTERNAL_STORAGE和WRITE_EXTERNAL_STORAGE权限&quot;, Toast.LENGTH_SHORT).show();
            break;
    }
}

@Override //申请失败时调用
public void onPermissionsDenied(int requestCode, List&lt;String&gt; list) {
    // 请求失败，执行相应操作
    
}
}
</code></pre>
<p>接下来就要说一下成功或者失败后的操作了： 申请成功就直接做该做的事就行了，没啥。
申请如果失败了，这时候有个方法出现了EasyPermissions.somePermissionPermanentlyDenied(this, perms)
这个方法是谷歌建议的。就是在我们点了不在询问并拒绝，会弹出对话框，告诉用户这个权限时干嘛的，很重要，建议不要拒绝哈哈
比如这样：</p>
<pre><code>@Override
public void onPermissionsDenied(int requestCode, List&lt;String&gt; perms) {

if (EasyPermissions.somePermissionPermanentlyDenied(this, perms)) {
    new AppSettingsDialog.Builder(this).build().show();
    //弹出个对话框
}
</code></pre>
<p>当然我们可以定制一下这个对话框：</p>
<pre><code>@Override
public void onPermissionsDenied(int requestCode, List&lt;String&gt; perms) {
    //处理权限名字字符串
    StringBuffer sb = new StringBuffer();
    for (String str : perms){
        sb.append(str);
        sb.append(&quot;\n&quot;);
    }
    sb.replace(sb.length() - 2,sb.length(),&quot;&quot;);

    switch (requestCode){
        case 0:
            Toast.makeText(this, &quot;已拒绝权限&quot; + perms.get(0), Toast.LENGTH_SHORT).show();
            break;
        case 1:
            Toast.makeText(this, &quot;已拒绝WRITE_EXTERNAL_STORAGE和WRITE_EXTERNAL_STORAGE权限&quot;+ perms.get(0), Toast.LENGTH_SHORT).show();
            break;
    }
    if (EasyPermissions.somePermissionPermanentlyDenied(this, perms)) {
        Toast.makeText(this, &quot;已拒绝权限&quot; + sb + &quot;并不再询问&quot; , Toast.LENGTH_SHORT).show();
        new AppSettingsDialog
                .Builder(this)
                .setRationale(&quot;此功能需要&quot; + sb + &quot;权限，否则无法正常使用，是否打开设置&quot;)
                .setPositiveButton(&quot;是&quot;)
                .setNegativeButton(&quot;否&quot;)
                .build()
                .show();
    }
}
</code></pre>
<h3 id="6-可选afterpermissiongranted注解">6、(可选)@AfterPermissionGranted()注解</h3>
<p>使用 AfterPermissioonGranted 注解。这是可选的，但是提供出来是为了方便。如果所有的请求的权限都被授予了，被注解的方法将会被执行，这样做是为了简化通常的请求权限成功之后再调用方法的流程。同时也可以在onPermissionsGranted 的回调中添加逻辑操作：
比如官网上的这个实例代码：
这里的方法名可以自己取，主要是权限都申请完，就调用这个方法，执行里面的操作。
其实就相当于在onPermissionsGranted()调用这个方法而已:</p>
<pre><code>@AfterPermissionGranted(RC_CAMERA_AND_LOCATION)
private void methodRequiresTwoPermission() {
String[] perms = {Manifest.permission.CAMERA, Manifest.permission.ACCESS_FINE_LOCATION};
if (EasyPermissions.hasPermissions(this, perms)) {
    // Already have permission, do the thing
    // ...
} else {
    // Do not have permissions, request them now
    EasyPermissions.requestPermissions(this, getString(R.string.camera_and_location_rationale),
            RC_CAMERA_AND_LOCATION, perms);
}
}
</code></pre>
<h3 id="4-android-80运行时权限">4、android 8.0运行时权限</h3>
<p>对于针对Android O的应用，此行为已被纠正。系统只会授予应用明确请求的权限。然而一旦用户为应用授予某个权限，则所有后续对该权限组中权限的请求都将被自动批准。</p>
<p>例如，假设某个应用在其清单中列出READ_EXTERNAL_STORAGE和WRITE_EXTERNAL_STORAGE。应用请求READ_EXTERNAL_STORAGE，并且用户授予了该权限，如果该应用针对的是API级别24或更低级别，系统还会同时授予WRITE_EXTERNAL_STORAGE，因为该权限也属于STORAGE权限组并且也在清单中注册过。如果该应用针对的是Android O，则系统此时仅会授予READ_EXTERNAL_STORAGE，不过在该应用以后申请WRITE_EXTERNAL_STORAGE权限时，系统会立即授予该权限，而不会提示用户。
注意：如果使用了没有授权的权限，会崩溃的</p>
<p>所以对于8.0权限，我们要做的处理，是尽量把所用到的危险权限全部申请。但是有的权限在不同版本出现，所以要兼容不同的版本，所以要加一个版本的判断。</p>
<pre><code>归根结底：android M (6.0)以后，申请权限组一个，即表示整个权限组可以用，所以我们干脆，只要api 版本大于23（6.0）,我们申请的权限就是申请整个权限组。这样就兼容了android8.0-------------------为了省事的话可以用AndPermission这个第三方框架，或者自己封装一个。
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[集成gitalk评论]]></title>
        <id>https://galiful.github.io/Resume//post/ji-cheng-gitalk-ping-lun</id>
        <link href="https://galiful.github.io/Resume//post/ji-cheng-gitalk-ping-lun">
        </link>
        <updated>2019-05-20T01:07:25.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://github.com/gitalk/gitalk/blob/master/readme-cn.md">gitalk</a>
存在由于文章标题过长时导致无法初始化（github pages 机制），解决办法在<a href="https://github.com/gitalk/gitalk/issues/124">这</a>
<img src="https://galiful.github.io/Resume//post-images/1558314852687.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[个人随笔转移到Github pages]]></title>
        <id>https://galiful.github.io/Resume//post/ge-ren-sui-bi-zhuan-yi-dao-github-pages</id>
        <link href="https://galiful.github.io/Resume//post/ge-ren-sui-bi-zhuan-yi-dao-github-pages">
        </link>
        <updated>2019-05-10T08:01:45.000Z</updated>
        <content type="html"><![CDATA[<p>今天2019年5月10日
将之前在<a href="https://www.jianshu.com/u/5b0d57ea33fe">简书</a>的个人转载也好，自己学习记录也好，转移到Github 开放仓库<a href="https://github.com/Galiful/Resume">Resume</a>中</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android Documentation 随笔]]></title>
        <id>https://galiful.github.io/Resume//post/android-documentation-sui-bi</id>
        <link href="https://galiful.github.io/Resume//post/android-documentation-sui-bi">
        </link>
        <updated>2019-04-18T07:37:29.000Z</updated>
        <content type="html"><![CDATA[<p><strong>Dialog</strong> 类是对话框的基类，但您应该避免直接实例化 Dialog，而是使用下列子类之一：</p>
<p><strong>AlertDialog</strong></p>
<p>此对话框可显示标题、最多三个按钮、可选择项列表或自定义布局。</p>
<p>DatePickerDialog 或 TimePickerDialog</p>
<p>此对话框带有允许用户选择日期或时间的预定义 UI。</p>
<p><strong>避免使用 ProgressDialog</strong></p>
<p>Android 包括另一种名为 ProgressDialog 的对话框类，可显示具有进度条的对话框。不过，如需指示加载进度或不确定的进度，则应改为遵循进度和 Activity 的设计指南，并在您的布局中使用 ProgressBar。</p>
<p>提示：默认情况下，当您将 EditText 元素设置为使用 &quot;textPassword&quot; 输入类型时，字体系列将设置为固定宽度。因此，您应该将其字体系列更改为 &quot;sans-serif&quot;，以便两个文本字段都使用匹配的字体样式。</p>
<p>提示：如·果您想要自定义对话框，可以改用对话框的形式显示 Activity，而不是使用 Dialog API。 只需创建一个 Activity，并在 <activity> 清单文件元素中将其主题设置为 Theme.Holo.Dialog：</p>
<p><code>&lt;activity android:theme=&quot;@android:style/Theme.Holo.Dialog&quot; &gt;</code></p>
<p>就这么简单。Activity 现在会显示在一个对话框窗口中，而非全屏显示。</p>
<p>要想仅在大屏幕上将 Activity 显示为对话框，请将 Theme.Holo.DialogWhenLarge 主题应用于 <activity> 清单文件元素：</p>
<p><code>&lt;activity android:theme=&quot;@android:style/Theme.Holo.DialogWhenLarge&quot; &gt;</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android 中简单实现8种Dialog]]></title>
        <id>https://galiful.github.io/Resume//post/android-zhong-jian-dan-shi-xian-8-chong-dialog</id>
        <link href="https://galiful.github.io/Resume//post/android-zhong-jian-dan-shi-xian-8-chong-dialog">
        </link>
        <updated>2019-04-18T07:36:49.000Z</updated>
        <content type="html"><![CDATA[<p>出处：<a href="https://www.cnblogs.com/gzdaijie/p/5222191.html">https://www.cnblogs.com/gzdaijie/p/5222191.html</a></p>
<h2 id="1写在前面">1.写在前面</h2>
<ul>
<li>Android提供了丰富的<code>Dialog</code>函数，本文介绍最常用的8种对话框的使用方法，包括普通（包含提示消息和按钮）、列表、单选、多选、等待、进度条、编辑、自定义等多种形式，将在第2部分介绍。</li>
<li>有时，我们希望在对话框创建或关闭时完成一些特定的功能，这需要<code>复写</code>Dialog的<code>create()</code>、<code>show()</code>、<code>dismiss()</code>等方法，将在第3部分介绍。</li>
</ul>
<h2 id="2代码示例">2.代码示例</h2>
<p><img src="http://upload-images.jianshu.io/upload_images/15775879-734b1a8a288c181f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片示例"></p>
<h3 id="21-普通dialog图1与图2">2.1 普通Dialog（图1与图2）</h3>
<ul>
<li><strong>2个按钮</strong></li>
</ul>
<pre><code>public class MainActivity extends Activity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button buttonNormal = (Button) findViewById(R.id.button_normal);
        buttonNormal.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                showNormalDialog();
            }
        });
    }

    private void showNormalDialog(){
        /* @setIcon 设置对话框图标
         * @setTitle 设置对话框标题
         * @setMessage 设置对话框消息提示
         * setXXX方法返回Dialog对象，因此可以链式设置属性
         */
        final AlertDialog.Builder normalDialog = 
            new AlertDialog.Builder(MainActivity.this);
        normalDialog.setIcon(R.drawable.icon_dialog);
        normalDialog.setTitle(&quot;我是一个普通Dialog&quot;)
        normalDialog.setMessage(&quot;你要点击哪一个按钮呢?&quot;);
        normalDialog.setPositiveButton(&quot;确定&quot;, 
            new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int which) {
                //...To-do
            }
        });
        normalDialog.setNegativeButton(&quot;关闭&quot;, 
            new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int which) {
                //...To-do
            }
        });
        // 显示
        normalDialog.show();
    }
}
</code></pre>
<ul>
<li><strong>3个按钮</strong></li>
</ul>
<pre><code>/* @setNeutralButton 设置中间的按钮
 * 若只需一个按钮，仅设置 setPositiveButton 即可
 */
private void showMultiBtnDialog(){
    AlertDialog.Builder normalDialog = 
        new AlertDialog.Builder(MainActivity.this);
    normalDialog.setIcon(R.drawable.icon_dialog);
    normalDialog.setTitle(&quot;我是一个普通Dialog&quot;).setMessage(&quot;你要点击哪一个按钮呢?&quot;);
    normalDialog.setPositiveButton(&quot;按钮1&quot;, 
        new DialogInterface.OnClickListener() {
        @Override
        public void onClick(DialogInterface dialog, int which) {
            // ...To-do
        }
    });
    normalDialog.setNeutralButton(&quot;按钮2&quot;, 
        new DialogInterface.OnClickListener() {
        @Override
        public void onClick(DialogInterface dialog, int which) {
            // ...To-do
        }
    });
    normalDialog.setNegativeButton(&quot;按钮3&quot;, new DialogInterface.OnClickListener() {
        @Override
        public void onClick(DialogInterface dialog, int which) {
            // ...To-do
        }
    });
    // 创建实例并显示
    normalDialog.show();
}

</code></pre>
<h3 id="22-列表dialog图3">2.2 列表Dialog（图3）</h3>
<pre><code>private void showListDialog() {
    final String[] items = { &quot;我是1&quot;,&quot;我是2&quot;,&quot;我是3&quot;,&quot;我是4&quot; };
    AlertDialog.Builder listDialog = 
        new AlertDialog.Builder(MainActivity.this);
    listDialog.setTitle(&quot;我是一个列表Dialog&quot;);
    listDialog.setItems(items, new DialogInterface.OnClickListener() {
        @Override
        public void onClick(DialogInterface dialog, int which) {
            // which 下标从0开始
            // ...To-do
            Toast.makeText(MainActivity.this, 
                &quot;你点击了&quot; + items[which], 
                Toast.LENGTH_SHORT).show();
        }
    });
    listDialog.show();
}
</code></pre>
<h3 id="23-单选dialog图4">2.3 单选Dialog（图4）</h3>
<pre><code>int yourChoice;
private void showSingleChoiceDialog(){
    final String[] items = { &quot;我是1&quot;,&quot;我是2&quot;,&quot;我是3&quot;,&quot;我是4&quot; };
    yourChoice = -1;
    AlertDialog.Builder singleChoiceDialog = 
        new AlertDialog.Builder(MainActivity.this);
    singleChoiceDialog.setTitle(&quot;我是一个单选Dialog&quot;);
    // 第二个参数是默认选项，此处设置为0
    singleChoiceDialog.setSingleChoiceItems(items, 0, 
        new DialogInterface.OnClickListener() {
        @Override
        public void onClick(DialogInterface dialog, int which) {
            yourChoice = which;
        }
    });
    singleChoiceDialog.setPositiveButton(&quot;确定&quot;, 
        new DialogInterface.OnClickListener() {
        @Override
        public void onClick(DialogInterface dialog, int which) {
            if (yourChoice != -1) {
                Toast.makeText(MainActivity.this, 
                &quot;你选择了&quot; + items[yourChoice], 
                Toast.LENGTH_SHORT).show();
            }
        }
    });
    singleChoiceDialog.show();
}
</code></pre>
<h3 id="24-多选dialog图5">2.4 多选Dialog（图5）</h3>
<pre><code>ArrayList&lt;Integer&gt; yourChoices = new ArrayList&lt;&gt;();
private void showMultiChoiceDialog() {
    final String[] items = { &quot;我是1&quot;,&quot;我是2&quot;,&quot;我是3&quot;,&quot;我是4&quot; };
    // 设置默认选中的选项，全为false默认均未选中
    final boolean initChoiceSets[]={false,false,false,false};
    yourChoices.clear();
    AlertDialog.Builder multiChoiceDialog = 
        new AlertDialog.Builder(MainActivity.this);
    multiChoiceDialog.setTitle(&quot;我是一个多选Dialog&quot;);
    multiChoiceDialog.setMultiChoiceItems(items, initChoiceSets,
        new DialogInterface.OnMultiChoiceClickListener() {
        @Override
        public void onClick(DialogInterface dialog, int which,
            boolean isChecked) {
            if (isChecked) {
                yourChoices.add(which);
            } else {
                yourChoices.remove(which);
            }
        }
    });
    multiChoiceDialog.setPositiveButton(&quot;确定&quot;, 
        new DialogInterface.OnClickListener() {
        @Override
        public void onClick(DialogInterface dialog, int which) {
            int size = yourChoices.size();
            String str = &quot;&quot;;
            for (int i = 0; i &lt; size; i++) {
                str += items[yourChoices.get(i)] + &quot; &quot;;
            }
            Toast.makeText(MainActivity.this, 
                &quot;你选中了&quot; + str, 
                Toast.LENGTH_SHORT).show();
        }
    });
    multiChoiceDialog.show();
}
</code></pre>
<h3 id="25-等待dialog图6">2.5 等待Dialog（图6）</h3>
<pre><code>private void showWaitingDialog() {
    /* 等待Dialog具有屏蔽其他控件的交互能力
     * @setCancelable 为使屏幕不可点击，设置为不可取消(false)
     * 下载等事件完成后，主动调用函数关闭该Dialog
     */
    ProgressDialog waitingDialog= 
        new ProgressDialog(MainActivity.this);
    waitingDialog.setTitle(&quot;我是一个等待Dialog&quot;);
    waitingDialog.setMessage(&quot;等待中...&quot;);
    waitingDialog.setIndeterminate(true);
    waitingDialog.setCancelable(false);
    waitingDialog.show();
}
</code></pre>
<h3 id="26-进度条dialog图7">2.6 进度条Dialog（图7）</h3>
<pre><code>private void showProgressDialog() {
    /* @setProgress 设置初始进度
     * @setProgressStyle 设置样式（水平进度条）
     * @setMax 设置进度最大值
     */
    final int MAX_PROGRESS = 100;
    final ProgressDialog progressDialog = 
        new ProgressDialog(MainActivity.this);
    progressDialog.setProgress(0);
    progressDialog.setTitle(&quot;我是一个进度条Dialog&quot;);
    progressDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);
    progressDialog.setMax(MAX_PROGRESS);
    progressDialog.show();
    /* 模拟进度增加的过程
     * 新开一个线程，每个100ms，进度增加1
     */
    new Thread(new Runnable() {
        @Override
        public void run() {
            int progress= 0;
            while (progress &lt; MAX_PROGRESS){
                try {
                    Thread.sleep(100);
                    progress++;
                    progressDialog.setProgress(progress);
                } catch (InterruptedException e){
                    e.printStackTrace();
                }
            }
            // 进度达到最大值后，窗口消失
            progressDialog.cancel();
        }
    }).start();
}
</code></pre>
<h3 id="27-编辑dialog图8">2.7 编辑Dialog（图8）</h3>
<pre><code>private void showInputDialog() {
    /*@setView 装入一个EditView
     */
    final EditText editText = new EditText(MainActivity.this);
    AlertDialog.Builder inputDialog = 
        new AlertDialog.Builder(MainActivity.this);
    inputDialog.setTitle(&quot;我是一个输入Dialog&quot;).setView(editText);
    inputDialog.setPositiveButton(&quot;确定&quot;, 
        new DialogInterface.OnClickListener() {
        @Override
        public void onClick(DialogInterface dialog, int which) {
            Toast.makeText(MainActivity.this,
            editText.getText().toString(), 
            Toast.LENGTH_SHORT).show();
        }
    }).show();
}
</code></pre>
<h3 id="28-自定义dialog图9">2.8 自定义Dialog（图9）</h3>
<pre><code>&lt;!-- res/layout/dialog_customize.xml--&gt;
&lt;!-- 自定义View --&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:orientation=&quot;vertical&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;&gt;
    &lt;EditText
        android:id=&quot;@+id/edit_text&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot; 
        /&gt;
&lt;/LinearLayout&gt;
</code></pre>
<pre><code>private void showCustomizeDialog() {
    /* @setView 装入自定义View ==&gt; R.layout.dialog_customize
     * 由于dialog_customize.xml只放置了一个EditView，因此和图8一样
     * dialog_customize.xml可自定义更复杂的View
     */
    AlertDialog.Builder customizeDialog = 
        new AlertDialog.Builder(MainActivity.this);
    final View dialogView = LayoutInflater.from(MainActivity.this)
        .inflate(R.layout.dialog_customize,null);
    customizeDialog.setTitle(&quot;我是一个自定义Dialog&quot;);
    customizeDialog.setView(dialogView);
    customizeDialog.setPositiveButton(&quot;确定&quot;,
        new DialogInterface.OnClickListener() {
        @Override
        public void onClick(DialogInterface dialog, int which) {
            // 获取EditView中的输入内容
            EditText edit_text = 
                (EditText) dialogView.findViewById(R.id.edit_text);
            Toast.makeText(MainActivity.this,
                edit_text.getText().toString(),
                Toast.LENGTH_SHORT).show();
        }
    });
    customizeDialog.show();
}
</code></pre>
<h2 id="3复写回调函数">3.复写回调函数</h2>
<pre><code>/* 复写Builder的create和show函数，可以在Dialog显示前实现必要设置
 * 例如初始化列表、默认选项等
 * @create 第一次创建时调用
 * @show 每次显示时调用
 */
private void showListDialog() {
    final String[] items = { &quot;我是1&quot;,&quot;我是2&quot;,&quot;我是3&quot;,&quot;我是4&quot; };
    AlertDialog.Builder listDialog = 
        new AlertDialog.Builder(MainActivity.this){

        @Override
        public AlertDialog create() {
            items[0] = &quot;我是No.1&quot;;
            return super.create();
        }

        @Override
        public AlertDialog show() {
            items[1] = &quot;我是No.2&quot;;
            return super.show();
        }
    };
    listDialog.setTitle(&quot;我是一个列表Dialog&quot;);
    listDialog.setItems(items, new DialogInterface.OnClickListener() {
        @Override
        public void onClick(DialogInterface dialog, int which) {
            // ...To-do
        }
    });
    /* @setOnDismissListener Dialog销毁时调用
     * @setOnCancelListener Dialog关闭时调用
     */
    listDialog.setOnDismissListener(new DialogInterface.OnDismissListener() {
        public void onDismiss(DialogInterface dialog) {
            Toast.makeText(getApplicationContext(),
                &quot;Dialog被销毁了&quot;, 
                Toast.LENGTH_SHORT).show();
        }
    });
    listDialog.show();
}
</code></pre>
<h2 id="另外可继承dialog类实现更多除布局以外更多的动作">另外可继承Dialog类实现更多除布局以外更多的动作</h2>
<pre><code>setContentView(R.layout.common_dialog_layout);
        //按空白处不能取消动画
        setCanceledOnTouchOutside(false);
        //初始化界面控件
        initView();
        //初始化界面数据
        refreshView();
        //初始化界面控件的事件
        initEvent();
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[github上的license-许可证]]></title>
        <id>https://galiful.github.io/Resume//post/github-shang-de-license-xu-ke-zheng</id>
        <link href="https://galiful.github.io/Resume//post/github-shang-de-license-xu-ke-zheng">
        </link>
        <updated>2019-03-29T07:36:10.000Z</updated>
        <content type="html"><![CDATA[<p>转载</p>
<p>介绍3个主流的许可证 :</p>
<p>MIT 许可证 -- 只要用户在项目副本中包含了版权声明和许可声明，他们就可以拿你的代码做任何想做的事情，你也无需承担任何责任。</p>
<p>Apache 许可证 -- 类似 MIT 许可证，但它同时还包含了贡献者向用户提供专利授权相关的条款。</p>
<p>GPL 许可证 -- 这是一种copyleft许可证，要求修改项目代码的用户再次分发源码或二进制代码时，必须公布他的相关修改。V3版本与V2类似，但其进一步约束了在某些限制软件更改的硬件上的使用范围。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[android之onClick和onTouch防止点击过快的处理方法]]></title>
        <id>https://galiful.github.io/Resume//post/android-zhi-onclick-he-ontouch-fang-zhi-dian-ji-guo-kuai-de-chu-li-fang-fa</id>
        <link href="https://galiful.github.io/Resume//post/android-zhi-onclick-he-ontouch-fang-zhi-dian-ji-guo-kuai-de-chu-li-fang-fa">
        </link>
        <updated>2019-03-16T07:34:27.000Z</updated>
        <content type="html"><![CDATA[<p>注：
<code>Calendar.getInstance().getTimeInMillis(); //每次调用onClick时的时间，可返回long</code></p>
<p><strong>onclick</strong></p>
<pre><code>public static final int MIN_CLICK_DELAY_TIME = 1000;

   private long lastClickTime = 0;

          @Override

          public void onClick(View v) {

              long currentTime = Calendar.getInstance().getTimeInMillis();

              if (currentTime - lastClickTime &gt; MIN_CLICK_DELAY_TIME) {

                  lastClickTime = currentTime;

                 /**
                  *执行代码
                  /

              }

          } 
</code></pre>
<p><strong>onTouch</strong>
（自写，由于onTouch抬起按下都会有监听事件，下面代码逻辑为：一次完整按下抬起过程没有时间限制，第二次按下须与上次抬起有MIN_CLICK_DELAY_TIME 间隔  ）</p>
<pre><code>public static final int MIN_CLICK_DELAY_TIME = 1000;
long upTime =0;
long downTime =0;

@Override

public boolean onTouch(View v, MotionEvent event) {

    if (event.getAction() == MotionEvent.ACTION_DOWN) {

            downTime = Calendar.getInstance().getTimeInMillis();

      }

    if (downTime -upTime &gt;MIN_CLICK_DELAY_TIME) {
                /**
                *执行代码
                 /
    }

    if(event.getAction() == MotionEvent.ACTION_UP){

            upTime=Calendar.getInstance().getTimeInMillis();

        }
return false;
}
</code></pre>
<p>如果程序需要在多个地方使用，可以自定义一个NoDoubleClickListener（NoDoubleTouchListener）,继承自OnClickListener（OnTouchListener）：</p>
<p>/代码2</p>
<pre><code>public abstract class NoDoubleClickListener implements OnClickListener {

		public static final int MIN_CLICK_DELAY_TIME = 1000;

		private long lastClickTime = 0;

		@Override

		public void onClick(View v) {

				long currentTime = Calendar.getInstance().getTimeInMillis();

				if (currentTime - lastClickTime &gt; MIN_CLICK_DELAY_TIME) {

						lastClickTime = currentTime;

						onNoDoubleClick(v);

				}

		} 

}

noDooubleButton.setOnClickListener(new NoDoubleClickListener() {

		@Override

		public void onNoDoubleClick(View v) {

				submitOrder();//执行代码

		}

});
</code></pre>
]]></content>
    </entry>
</feed>