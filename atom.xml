<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://galiful.github.io/Resume/</id>
    <title>Galiful</title>
    <updated>2019-09-26T05:08:51.867Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://galiful.github.io/Resume/"/>
    <link rel="self" href="https://galiful.github.io/Resume//atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://galiful.github.io/Resume//images/avatar.png</logo>
    <icon>https://galiful.github.io/Resume//favicon.ico</icon>
    <rights>All rights reserved 2019, Galiful</rights>
    <entry>
        <title type="html"><![CDATA[QT 无边框窗口-拖动移动]]></title>
        <id>https://galiful.github.io/Resume//post/qt-wu-bian-kuang-chuang-kou-tuo-dong-yi-dong</id>
        <link href="https://galiful.github.io/Resume//post/qt-wu-bian-kuang-chuang-kou-tuo-dong-yi-dong">
        </link>
        <updated>2019-08-30T04:09:37.000Z</updated>
        <content type="html"><![CDATA[<pre><code>//去掉标题栏，无边框窗口，区别是第一个可以鼠标缩放窗口，但上方有一个白条故未采用
	//setWindowFlags(Qt::CustomizeWindowHint);
	setWindowFlags(Qt::FramelessWindowHint);
</code></pre>
<pre><code>void Qwebengine::mousePressEvent(QMouseEvent* event)
{
	if (event-&gt;button() == Qt::LeftButton)
	{
		mMousePressed = true;
		mRelativeSrcPos = event-&gt;globalPos() - pos();
	}
}

void Qwebengine::mouseReleaseEvent(QMouseEvent* event)
{
	mMousePressed = false;
}

void Qwebengine::mouseMoveEvent(QMouseEvent* event)
{
	if (mMousePressed)
	{
		//当前位置减去相对的原点位置得到的是移动距离
		move(event-&gt;globalPos() - mRelativeSrcPos);
	}
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[QWebEngine之与webkit]]></title>
        <id>https://galiful.github.io/Resume//post/qwebengine-zhi-yu-webkit</id>
        <link href="https://galiful.github.io/Resume//post/qwebengine-zhi-yu-webkit">
        </link>
        <updated>2019-08-28T00:04:02.000Z</updated>
        <content type="html"><![CDATA[<p>自从Qt5.6后引入了QWebEngine，摒弃了原先的QWebkit，这是一款基于chrome浏览器内核引擎，Qt webenginewidgets模块中提供了QWebEngineView这个视图控件来很方便的加载和显示网页，仅需如下几行：</p>
<pre><code>QWebEngineView* webview = new QWebEngineView;
webview-&gt;load(QUrl(&quot;https://www.baidu.com/&quot;));
webview-&gt;show();
</code></pre>
<p>与webkit主要区别：<br>
<img src="https://galiful.github.io/Resume//post-images/1566950985824.png" alt=""><br>
在我的项目里：webkit不能执行网页里js脚本（也可能是脚本不兼容）~而webengine确可以。</p>
<p>webengine尽管功能更强，但用到QtWebEngineProcess.exe 占用内存更大</p>
<pre><code>QWebEngineProfile* engineProfile = ui.webEngineView-&gt;page()-&gt;profile();
	engineProfile-&gt;clearHttpCache(); //删除缓存
	QWebEngineCookieStore* cookie = ui.webEngineView-&gt;page()-&gt;profile()-&gt;cookieStore();
	cookie-&gt;deleteAllCookies();//删除cookie 
</code></pre>
<p>刷新时执行此操作，明显看到内存降低然后随网页打开再回升的一个过程，证明可用~</p>
<pre><code>将QtWebEngineProcess.exe与主进程合二为一。
qputenv(&quot;QTWEBENGINE_CHROMIUM_FLAGS&quot;, &quot;--single-process&quot;);
</code></pre>
<p>QWebEngineView的一些设置方法：</p>
<pre><code>ui.webEngineView-&gt;settings()-&gt;setAttribute(QWebEngineSettings::ShowScrollBars, false);//隐藏滚动条
</code></pre>
<p><a href="https://doc.qt.io/qt-5/qwebenginesettings.html">https://doc.qt.io/qt-5/qwebenginesettings.html</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一个基于qt的桌面应用开发经历]]></title>
        <id>https://galiful.github.io/Resume//post/yi-ge-ji-yu-qt-de-zhuo-mian-ying-yong</id>
        <link href="https://galiful.github.io/Resume//post/yi-ge-ji-yu-qt-de-zhuo-mian-ying-yong">
        </link>
        <updated>2019-08-26T05:20:18.000Z</updated>
        <content type="html"><![CDATA[<p>这一个月没有更新日志和git。。。<br>
因为在忙一个桌面应用，因为之前都没有怎么接触过，环境和代码都是一点点摸索，自是也没有传git。<br>
项目需求是显示画面，和服务器传来的数据，做界面显示，功能很简单<br>
摄像头用的网络摄像头，对，萤石<br>
界面显示用qt，没啥动画也不会，<br>
中间画面本来用的是萤石demo，后来基本完成了，项目要求画面换协议，于是用的是webengine显示网页的形式，<br>
项目目前有近2个月时间了，基本完成，后面可能还有改，因为项目对画面延迟要求很高~</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[App内异常捕获并上传]]></title>
        <id>https://galiful.github.io/Resume//post/app-nei-yi-chang-bu-huo</id>
        <link href="https://galiful.github.io/Resume//post/app-nei-yi-chang-bu-huo">
        </link>
        <updated>2019-06-17T00:44:10.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>实现Thread.UncaughtExceptionHandler接口</li>
<li>腾讯Bugly等第三方</li>
</ol>
<pre><code>CrashHandler crashHandler = CrashHandler.getInstance();
crashHandler.init(this);
</code></pre>
<pre><code>public class CrashHandler implements Thread.UncaughtExceptionHandler {
    private static final String TAG = &quot;CrashHandler&quot;;
    private static final boolean DEBUG = true;
    //文件路径
    private static final String PATH = Environment.getExternalStorageDirectory().getPath() +File.separator+ &quot;crash&quot;;
    private static final String FILE_NAME = &quot;crash&quot;;
    private static final String FILE_NAME_SUFEIX = &quot;.trace&quot;;
    private static Thread.UncaughtExceptionHandler mDefaultCrashHandler;
    private static CrashHandler mCrashHandler = new CrashHandler();
    private Context mContext;

    private CrashHandler() {
    }

    public static CrashHandler getInstance() {
        return mCrashHandler;
    }

    public void init(Context context) {
        mDefaultCrashHandler = Thread.getDefaultUncaughtExceptionHandler();
        Thread.setDefaultUncaughtExceptionHandler(this);
        mContext = context.getApplicationContext();
    }

    @Override
    public void uncaughtException(Thread thread, Throwable ex) {
        try {
            //将文件写入sd卡
            writeToSDcard(ex);
            //写入后在这里可以进行上传操作
        } catch (IOException e) {
            e.printStackTrace();
        } catch (PackageManager.NameNotFoundException e) {
            e.printStackTrace();
        }
        ex.printStackTrace();
        //如果系统提供了默认异常处理就交给系统进行处理，否则自己进行处理。
        if (mDefaultCrashHandler != null) {
            mDefaultCrashHandler.uncaughtException(thread, ex);
        } else {
            //Process.killProcess(Process.myPid());
        }
    }

    //将异常写入文件
    private void writeToSDcard(Throwable ex) throws IOException, PackageManager.NameNotFoundException {
        //如果没有SD卡，直接返回
        if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {
            return;
        }
        File filedir = new File(PATH);
        if (!filedir.exists()) {
            filedir.mkdirs();
        }
        long currenttime = System.currentTimeMillis();
        String time = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(new Date(currenttime));

        File exfile = new File(PATH +File.separator+FILE_NAME+time + FILE_NAME_SUFEIX);
        PrintWriter pw = new PrintWriter(new BufferedWriter(new FileWriter(exfile)));
        Log.e(&quot;错误日志文件路径&quot;,&quot;&quot;+exfile.getAbsolutePath());
        pw.println(time);
        PackageManager pm = mContext.getPackageManager();
        PackageInfo pi = pm.getPackageInfo(mContext.getPackageName(), PackageManager.GET_ACTIVITIES);
        //当前版本号
        pw.println(&quot;App Version:&quot; + pi.versionName + &quot;_&quot; + pi.versionCode);
        //当前系统
        pw.println(&quot;OS version:&quot; + Build.VERSION.RELEASE + &quot;_&quot; + Build.VERSION.SDK_INT);
        //制造商
        pw.println(&quot;Vendor:&quot; + Build.MANUFACTURER);
        //手机型号
        pw.println(&quot;Model:&quot; + Build.MODEL);
        //CPU架构
        pw.println(&quot;CPU ABI:&quot; + Build.CPU_ABI);

        ex.printStackTrace(pw);
        pw.close();

    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[人生苦短，我有Python]]></title>
        <id>https://galiful.github.io/Resume//post/ren-sheng-ku-duan-wo-you-python</id>
        <link href="https://galiful.github.io/Resume//post/ren-sheng-ku-duan-wo-you-python">
        </link>
        <updated>2019-06-15T05:31:04.000Z</updated>
        <content type="html"><![CDATA[<h2 id="20196">2019.6</h2>
<p>Python 是一种解释型语言： 这意味着开发过程中没有了编译这个环节。类似于PHP和Perl语言。</p>
<p>Python 是交互式语言： 这意味着，您可以在一个 Python 提示符 &gt;&gt;&gt; 后直接执行代码。</p>
<p>Python 是面向对象语言: 这意味着Python支持面向对象的风格或代码封装在对象的编程技术。</p>
<p>Python 是初学者的语言：Python 对初级程序员而言，是一种伟大的语言，它支持广泛的应用程序开发，从简单的文字处理到 WWW 浏览器再到游戏。<br>
<em>总之，优雅~</em></p>
<p>优点</p>
<ul>
<li>简单 -- Python 是一种代表简单主义思想的语言。阅读一个良好的 Python 程序就感觉像是在读英语一样，尽管这个英语的要求非常严格！Python 的这种伪代码本质是它最大的优点之一。它使你能够专注于解决问题而不是去搞明白语言本身。</li>
<li>易学 -- 就如同你即将看到的一样，Python 极其容易上手。前面已经提到了，Python 有极其简单的语法。</li>
<li>免费、开源 -- Python 是 FLOSS（自由/开放源码软件）之一。简单地说，你可以自由地发布这个软件的拷贝、阅读它的源代码、对它做改动、把它的一部分用于新的自由软件中。FLOSS 是基于一个团体分享知识的概念。这是为什么 Python 如此优秀的原因之一——它是由一群希望看到一个更加优秀的 Python 的人创造并经常改进着的。</li>
<li>高层语言 -- 当你用 Python 语言编写程序的时候，你无需考虑诸如如何管理你的程序使用的内存一类的底层细节。</li>
<li>可移植性 -- 由于它的开源本质，Python 已经被移植在许多平台上（经过改动使它能够工作在不同平台上）。如果你小心地避免使用依赖于系统的特性，那么你的所有 Python 程序无需修改就可以在下述任何平台上面运行。这些平台包括 Linux、Windows、FreeBSD、Macintosh、Solaris、OS/2、Amiga、AROS、AS/400、BeOS、OS/390、z/OS、Palm OS、QNX、VMS、Psion、Acom RISC OS、VxWorks、PlayStation、Sharp Zaurus、Windows CE 甚至还有 PocketPC、Symbian 以及 Google 基于 Linux 开发的 Android 平台！</li>
<li>解释性 -- 这一点需要一些解释。一个用编译性语言比如 C 或 C++ 写的程序可以从源文件（即 C 或 C++ 语言）转换到一个你的计算机使用的语言（二进制代码，即0和1）。这个过程通过编译器和不同的标记、选项完成。当你运行你的程序的时候，连接/转载器软件把你的程序从硬盘复制到内存中并且运行。而 Python 语言写的程序不需要编译成二进制代码。你可以直接从源代码运行程序。在计算机内部，Python 解释器把源代码转换成称为字节码的中间形式，然后再把它翻译成计算机使用的机器语言并运行。事实上，由于你不再需要担心如何编译程序，如何确保连接转载正确的库等等，所有这一切使得使用 Python 更加简单。由于你只需要把你的 Python 程序拷贝到另外一台计算机上，它就可以工作了，这也使得你的 Python 程序更加易于移植。</li>
<li>面向对象 -- Python 既支持面向过程的编程也支持面向对象的编程。在“面向过程”的语言中，程序是由过程或仅仅是可重用代码的函数构建起来的。在“面向对象”的语言中，程序是由数据和功能组合而成的对象构建起来的。与其他主要的语言如 C++ 和 Java 相比，Python 以一种非常强大又简单的方式实现面向对象编程。</li>
<li>可扩展性 -- 如果你需要你的一段关键代码运行得更快或者希望某些算法不公开，你可以把你的部分程序用 C 或 C++ 编写，然后在你的 Python 程序中使用它们。</li>
<li>丰富的库 -- Python 标准库确实很庞大。它可以帮助你处理各种工作，包括正则表达式、文档生成、单元测试、线程、数据库、网页浏览器、CGI、FTP、电子邮件、XML、XML-RPC、HTML、WAV 文件、密码系统、GUI（图形用户界面）、Tk 和其他与系统有关的操作。记住，只要安装了 Python，所有这些功能都是可用的。这被称作 Python 的“功能齐全”理念。除了标准库以外，还有许多其他高质量的库，如 wxPython、Twisted 和 Python 图像库等等。</li>
<li>规范的代码 -- Python 采用强制缩进的方式使得代码具有极佳的可读性。</li>
</ul>
<p>缺点</p>
<ul>
<li>运行速度，有速度要求的话，用 C++ 改写关键部分吧。</li>
<li>国内市场较小（国内以 Python 来做主要开发的，目前只有一些 web2.0 公司）。但时间推移，目前很多国内软件公司，尤其是游戏公司，也开始规模使用他。</li>
<li>中文资料匮乏（好的 Python 中文资料屈指可数，现在应该变多了）。托社区的福，有几本优秀的教材已经被翻译了，但入门级教材多，高级内容还是只能看英语版。</li>
<li>构架选择太多（没有像 C# 这样的官方 .net 构架，也没有像 ruby 由于历史较短，构架开发的相对集中。Ruby on Rails 构架开发中小型web程序天下无敌）。不过这也从另一个侧面说明，python比较优秀，吸引的人才多，项目也多。</li>
</ul>
<p>目前python广泛应用于机器学习，数据分析，服务端建设~以上缺点较老旧</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Handler类中发送消息-post()和postDelay()方法]]></title>
        <id>https://galiful.github.io/Resume//post/handler-lei-zhong-fa-song-xiao-xi-posthe-postdelayfang-fa</id>
        <link href="https://galiful.github.io/Resume//post/handler-lei-zhong-fa-song-xiao-xi-posthe-postdelayfang-fa">
        </link>
        <updated>2019-06-10T09:49:27.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://img-blog.csdn.net/20180326181513374?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTEwMTE3Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br>
<img src="https://img-blog.csdn.net/20180326181526567?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTEwMTE3Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br>
首先，post和postDelay都是Handler的方法，用以在子线程中发送Runnable对象的方法；</p>
<p>其次，Android中post()方法可以直接在非UI线程中更新UI，不同与Handelr的Send类方法，需要进行切换；</p>
<p>最后，两个方法在实现UI线程事件的时间上有所区别，postDelayed()方法用以延期执行，post则是立即执行。<br>
// 三种切回主线程更新UI的方法<br>
```<br>
imageView.post(new Runnable() {<br>
@Override<br>
public void run() {<br>
imageView.setImageBitmap(bitmap1); // 素描图<br>
}<br>
});</p>
<pre><code>            runOnUiThread(new Runnable() {
                @Override
                public void run() {
                    orignView.setImageBitmap(bitmap2); // 素描图
                }
            });

            handler.post(new Runnable() {
                @Override
                public void run() {
                    threeView.setImageBitmap(bitmap3); // 素描图
                }
            });
</code></pre>
<pre><code>  
send方法：  

private Handler handler = new Handler(){
    @Override
    public void handleMessage(Message msg) {
        super.handleMessage(msg);
        switch (msg.what) {      //判断标志位
            case 1:
                /**
                 获取数据，更新UI
                */
                break;
        }
    }
};
   
 
public class WorkThread extends Thread {
 
    @Override
    public void run() {
        super.run();
       /**
         耗时操作
        */
  
        //从全局池中返回一个message实例，避免多次创建message（如new Message）
        Message msg =Message.obtain();  
        msg.obj = data;
        msg.what=1;   //标志消息的标志
        handler.sendMessage(msg);
    } 
}




</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[两种Activity的生命周期及Camera资源的释放]]></title>
        <id>https://galiful.github.io/Resume//post/liang-chong-activity-de-sheng-ming-zhou-qi-ji-camera-zi-yuan-de-shi-fang</id>
        <link href="https://galiful.github.io/Resume//post/liang-chong-activity-de-sheng-ming-zhou-qi-ji-camera-zi-yuan-de-shi-fang">
        </link>
        <updated>2019-06-10T00:03:10.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>在一次项目中尝试使用DialogActivity（对话框式活动）时又恰巧调用了摄像头，有oneActivity（普通活动）和twoActivity（对话框式活动），两个活动均使用了摄像头，oneActivity跳转到twoActivity时，即使做了资源释放，跳转时twoActivity摄像头正常，但back回oneActivity时，oneActivity摄像头异常（画面不动），按home后（执行onResume）后正常，可刚刚按back时执行了onResume了的。可当twoActivity为普通活动时，又一切正常~~~</p>
</blockquote>
<h3 id="再次认识活动的生命周期">再次认识活动的生命周期</h3>
<p>一 返回栈<br>
1.定义： Android是使用任务（Task）来管理活动的，一个任务就是一组存放在栈里的活动 的集合这个栈也被称作返回栈（Back Stack）。<br>
2.栈顶：存放刚启动的一个新的活动。（当我们 按下 Back键或调用 finish()方法去销毁一个活动时，处于栈顶的活动会出栈，这时前一个入 栈的活动就会重新处于栈顶的位置。系统总是会显示处于栈顶的活动给用户。）</p>
<p>二 活动状态<br>
1.运行状态：活动位于返回栈的栈顶时（系统最不愿意回收的 就是处于运行状态的活动，因为这会带来非常差的用户体验。）</p>
<p>2.暂停状态：当一个活动不再处于栈顶位置，但仍然可见时（比如某个活动上面新开了个对话框活动该活动就是暂停活动-系统也不愿意去回收这 种活动。）</p>
<p>3.停止状态：当一个活动不再处于栈顶位置，并且完全不可见的时候，就进入了停止状态。（系统 仍然会为这种活动保存相应的状态和成员变量，但很容易被回收）</p>
<p>4.销毁状态：当一个活动从返回栈中移除后就变成了销毁状态（系统会最倾向于回收处于这种状 态的活动，从而保证手机的内存充足。）</p>
<p>三 创建活动的生存期<br>
1.onCreate()：它会在活动 第一次被创建的时候调用用于加载布局、绑定事件等。</p>
<p>2.onStart()：这个方法在活动由不可见变为可见的时候调用。</p>
<p>3.onResume()：这个方法在活动准备好和用户进行交互的时候调用。此时的活动一定位于返回栈的 栈顶，并且处于运行状态。</p>
<p>4.onPause()： 这个方法在系统准备去启动或者恢复另一个活动的时候调用。</p>
<p>5.onStop()：  这个方法在活动完全不可见的时候调用。-----（如 果启动的新活动是一个对话框式的活动，那么 onPause()方法会得到执行，而 onStop() 方法并不会执行。）。</p>
<p>6.onDestroy()：这个方法在活动被销毁之前调用，之后活动的状态将变为销毁状态。</p>
<p>7.onRestart()：活动被重新启动时调用。</p>
<p><strong>完整生存期</strong>：【 onCreate()~ onDestroy()】之间。<br>
<strong>可见生存期</strong>：【 onStart()~ onStop()】之间。活动对于用户总是可见的！（我们可以通过这两个方法对资源进行加载和释放）<br>
<strong>前台生存期</strong>：【 onResume()~ onPause()】之间。活动总是处于运行状态的！（可以和用户进行相互。）</p>
<h3 id="演绎">演绎</h3>
<p>重温以上知识点后重新演绎上述场景，<br>
<strong>twoActivity为正常活动时</strong>：<br>
MainActivity   执行：<br>
onCreate()<br>
onStart()<br>
onResume() 方法<br>
然后点击第一个按钮启动 NormalActivity：（由于 NormalActivity已经把 MainActivity完全遮挡住，）<br>
执行：<br>
onPause()<br>
onStop()<br>
然后按下 Back键返回 MainActivity（由于之前 MainActivity已经进入了停止状态）<br>
执行：<br>
onRestart()<br>
onStart()<br>
onResume()</p>
<p><strong>twoActivity为对话框活动时</strong>：<br>
然后再点击第二个按钮，启动 DialogActivity（DialogActivity并没有完全遮挡住 MainActivity）<br>
执行：<br>
onPause()<br>
Back键返回 MainActivity<br>
执行：<br>
onResume()<br>
最后在 MainActivity按下 Back键退出程序<br>
执行：<br>
onPause()<br>
onStop()<br>
onDestroy()</p>
<p><strong>结论</strong>：<strong>dialogActivity不会执行onStop、onRestart()、 onStart()</strong>，导致相机资源没有正常回调（也许可以通过修改相机类修复）<br>
下面是项目中（asrDemo→DetectLoginActivity）生命周期log：<br>
<img src="https://galiful.github.io/Resume//post-images/1560134889431.png" alt=""><br>
可见在这台设备上，在执行AsrDemo onPause后就执行了DetectLoginActivity onCreate，如果没有合理释放资源必然出现占用错误（camera can not connect 等...）<br>
当DetectLoginActivity为对话框式活动时生命周期log：<br>
<img src="https://galiful.github.io/Resume//post-images/1560134787747.png" alt=""><br>
<strong>这次跳转过程asrDemo中camera并没有回调发生</strong><br>
在asrDemo、DetectLoginActivity中camera释放放在onPause()，以在asrDemo跳转和DetectLoginActivity back时释放。</p>
<h3 id="小结">小结</h3>
<p>关于如何解决在有camera活动打开另一个camera活动，且第二个又是DialogActivity，中的camera正常调用问题?<br>
本次项目做法是将第二个活动改为普通活动（黑线~）<br>
有大佬说可以把dialogActivity改为<strong>DialogFragment</strong>，生命周期就正常了，自己做了尝试，跟继承Dialog类似，由于项目设计代码较多且是引用的，半途中止，先实现功能再说，后面自己写时尝试再使用DialogFragment看看效果</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于application的继承]]></title>
        <id>https://galiful.github.io/Resume//post/guan-yu-application-de-ji-cheng</id>
        <link href="https://galiful.github.io/Resume//post/guan-yu-application-de-ji-cheng">
        </link>
        <updated>2019-06-04T00:01:53.000Z</updated>
        <content type="html"><![CDATA[<h2 id="记一次集成百度facesdk中遇到的知识盲点">记一次集成百度facesdk中遇到的知识盲点。</h2>
<p>一些app通过继承application作为 应用程序入口调用，避免手机内存过小,杀死后台进程（在手机设置里面，对应于某一个应用，虽然没有启动，但是上面有一个终止按钮，说明这个应用时启动的，只是里面没有Activity,所以说使用android退出把一个应用退出，实际上他所对应的Application是没有退出的（因为他的生命周期最长），只是对应的Activity退出了而已）</p>
<h3 id="认识application">认识application：</h3>
<p>android开发文档中关于application的描述 :<br>
Base class for those who need to maintain global application state. You can provide your own implementation by specifying its name in your AndroidManifest.xml's &lt; application&gt; tag, which will cause that class to be instantiated for you when the process for your application/package is created.</p>
<h4 id="application-配置全局context">Application 配置全局Context</h4>
<p>第一步、写一个全局的单例模式的MyApplication继承自Application 覆盖onCreate ，在这个方法里面实例化Application,并且值是全局的,可以使用Context的 getApplicationContext或者Activity的getApplication方法来获得一个application对象来拿到它。</p>
<ol>
<li>
<p>oncreate方法<br>
application对应的也有一个onCreate,这个才是真正的入口，不过一般我们使用的是Activity的onCreate方法作为入口使用了。<br>
<em>开发文档描述</em>：<br>
* Called when the application is starting, before any other application<br>
* objects have been created.  Implementations should be as quick as<br>
* possible (for example using lazy initialization of state) since the time<br>
* spent in this function directly impacts the performance of starting the<br>
* first activity, service, or receiver in a process.<br>
* If you override this method, be sure to call super.onCreate()</p>
</li>
<li>
<p>onConfigurationChanged方法<br>
当屏幕方向发生改变了，就会调用这个方法，并且对应的Activity中也会调用对应的方法<br>
因此不必再次处理</p>
</li>
</ol>
<p>第二步、配置全局的Context<br>
<code>&lt;application android:name=&quot;com.example.demo.MyApplication&quot; &gt;&lt;/application&gt;</code></p>
<p>第三步、使用的时候用的时候根据类的名称访问Context，manifest文件<application>有一项是android:name属性，一般你新建一个android项目的话，这个name属性是没有的，如果想要使用自定义的MyApplication的话，就要添加上一个name属性，如上面显示的那样，然后自定义一个类：MyApplication来继承application即可</p>
<h4 id="android程序的入口点">Android程序的入口点</h4>
<p>Android使用Google Dalvik VM，相对于传统Java VM而言有着很大的不同，在Sun的Java体系中入口点和标准c语言一样是main()，而每个Android程序都包含着一个Application实例，一个Application实例中有多个Activity、Service、ContentProvider或Broadcast Receiver。因为大部分的应用都包含Activity所以，说很多网友认为是Activity的onCreate，但是你没有发现你的工程中有多个Activity吗? 你可能没有见过没有Activity的Android应用吧。其实在android.app.Application这个包的onCreate才是真正的Android入口点，只不过大多数开发者无需重写该类，他的继承关系如下图:</p>
<p>java.lang.Object<br>
? android.content.Context<br>
? android.content.ContextWrapper<br>
? android.app.Application</p>
<p>android.app.Application类包含了4个公开的方法</p>
<p>void  onConfigurationChanged(Configuration newConfig)<br>
void  onCreate()  //这里才是真正的入口点。<br>
void  onLowMemory()<br>
void  onTerminate()</p>
<p>所以希望大家，记住真正的Android入口点是application的main，你可以看下androidmanifest.xml的包含关系就清楚了，并不是每个应用都必须有Activity的。</p>
<pre><code>问题一：
在这次集成中，原项目和facesdk 都使用application继承类作为程序入口初始化，知道这个后：
</code></pre>
<h4 id="android中两个application该如何继承和声明">Android中两个application该如何继承和声明？</h4>
<pre><code>1.继承：假如你有两个application类：ApplicationOne.java和ApplicationTwo.java
</code></pre>
<p>ApplicationOne才是你真正的程序入口，ApplicationTwo是第三方sdk或库里定义的，那么你可以把ApplicationOne继承于ApplicationTwo。</p>
<p>2.声明：在AndroidManifest.xml里声明的时候，只需要声明ApplicationOne就行了。因为AndroidManifest.xml中第一个注册的Application才真正会被PackageManager解析，才是有效的。<br>
<img src="https://galiful.github.io/Resume//post-images/1559609327818.png" alt=""><br>
详见：<a href="https://developer.android.google.cn/reference/android/app/Application?hl=en">Application  |  Android Developers</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[EasyPermissions的使用]]></title>
        <id>https://galiful.github.io/Resume//post/easypermissions-de-shi-yong</id>
        <link href="https://galiful.github.io/Resume//post/easypermissions-de-shi-yong">
        </link>
        <updated>2019-05-27T01:58:26.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://segmentfault.com/a/1190000012247350">https://segmentfault.com/a/1190000012247350</a></p>
<p>GitHub地址：https://github.com/googlesamp...<br>
EasyPermissions是谷歌封装的一个运行时权限申请的库，简化了操作的过程。<br>
使用过程： 没有什么先后顺序，下面没有按这个顺序。这么做是可以的，当然还有其他的使用方法</p>
<blockquote>
<p>1、builde gradle中依赖<br>
2、清单文件中声明权限<br>
3、重写onRequestPermissionsResult()方法，把执行操作给easyPermissions来<br>
4、通过hasPermissions检查权限，或者原生的也行，然后去申请权限<br>
5、实现EasyPermissions.PermissionCallbacks接口，重写两个方法，成功或失败<br>
6、在成功或者失败方法中编写要具体做的事。</p>
</blockquote>
<h3 id="github地址">GitHub地址：</h3>
<p>(1)依赖库</p>
<pre><code>dependencies {
    compile 'pub.devrel:easypermissions:1.0.1'
}
</code></pre>
<p>(2)再在清单文件中声明要申请的危险权限<br>
如果不声明的话，直接在代码中写也能申请成功，但是好想不会弹出询问框，直接就申请了</p>
<p>(3)申请权限<br>
可以直接申请</p>
<pre><code>EasyPermissions.requestPermissions(
                    MainActivity.this,
                    &quot;申请权限&quot;,
                    0,
                    Manifest.permission.WRITE_EXTERNAL_STORAGE,
                    Manifest.permission.RECORD_AUDIO);
</code></pre>
<p>最好还是检查一下权限是否申请：<br>
EasyPermissions.hasPermissions(Context context, @NonNull String… perms)方法来检测一个或者多个权限是否被允许，第二个参数是个可变数组，可以申请多个</p>
<pre><code>String[] perms = {Manifest.permission.CAMERA, Manifest.permission.ACCESS_FINE_LOCATION};
if (EasyPermissions.hasPermissions(this, perms)) {
    
    // 已经申请过权限，做想做的事
} else {
    // 没有申请过权限，现在去申请
    EasyPermissions.requestPermissions(this, getString(R.string.camera_and_location_rationale),
            RC_CAMERA_AND_LOCATION, perms);
}
</code></pre>
<p>下面来说一个申请权限这个方法：<br>
EasyPermissions.requestPermissions():<br>
requestPermissions() 一般用这个四个参数的就可以<br>
第一个参数：Context对象<br>
第二个参数：权限弹窗上的文字提示语。告诉用户，这个权限用途。<br>
第三个参数：这次请求权限的唯一标识请求码，code。<br>
第四个参数 : 一些系列的权限。<br>
这里说一下第二个参数，不是第一次申请系统默认弹出的提示语，而是，我们拒绝后，再次点击申请弹出的对话框，，显示我们设置的提示语，下面有两个按钮，确认和取消，我就不贴图了。</p>
<p>还有六个参数的，多了两个参数就是，修改我们上面那个确认和取消的字样，你可以干成yes 和no.</p>
<h3 id="4-重写onrequestpermissionsresult方法把执行操作给easypermissions">4、重写onRequestPermissionsResult()方法，把执行操作给easyPermissions</h3>
<p>一行代码就搞定了</p>
<pre><code> @Override
public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
    super.onRequestPermissionsResult(requestCode, permissions, grantResults);
    EasyPermissions.onRequestPermissionsResult(requestCode, permissions, grantResults, this);
}
</code></pre>
<p>5、实现EasyPermissions.PermissionCallbacks接口，重写两个方法</p>
<pre><code>public class MainActivity extends AppCompatActivity implements EasyPermissions.PermissionCallbacks {

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
}

@Override
public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
    super.onRequestPermissionsResult(requestCode, permissions, grantResults);

    // 把执行结果的操作给EasyPermissions
    EasyPermissions.onRequestPermissionsResult(requestCode, permissions, grantResults, this);
}

@Override //申请成功时调用
public void onPermissionsGranted(int requestCode, List&lt;String&gt; list) {
    //请求成功执行相应的操作
    
    比如，举个例子
    switch (requestCode){
        case 0:
            Toast.makeText(this, &quot;已获取WRITE_EXTERNAL_STORAGE权限&quot;, Toast.LENGTH_SHORT).show();
            break;
        case 1:
            Toast.makeText(this, &quot;已获取WRITE_EXTERNAL_STORAGE和WRITE_EXTERNAL_STORAGE权限&quot;, Toast.LENGTH_SHORT).show();
            break;
    }
}

@Override //申请失败时调用
public void onPermissionsDenied(int requestCode, List&lt;String&gt; list) {
    // 请求失败，执行相应操作
    
}
}
</code></pre>
<p>接下来就要说一下成功或者失败后的操作了： 申请成功就直接做该做的事就行了，没啥。<br>
申请如果失败了，这时候有个方法出现了EasyPermissions.somePermissionPermanentlyDenied(this, perms)<br>
这个方法是谷歌建议的。就是在我们点了不在询问并拒绝，会弹出对话框，告诉用户这个权限时干嘛的，很重要，建议不要拒绝哈哈<br>
比如这样：</p>
<pre><code>@Override
public void onPermissionsDenied(int requestCode, List&lt;String&gt; perms) {

if (EasyPermissions.somePermissionPermanentlyDenied(this, perms)) {
    new AppSettingsDialog.Builder(this).build().show();
    //弹出个对话框
}
</code></pre>
<p>当然我们可以定制一下这个对话框：</p>
<pre><code>@Override
public void onPermissionsDenied(int requestCode, List&lt;String&gt; perms) {
    //处理权限名字字符串
    StringBuffer sb = new StringBuffer();
    for (String str : perms){
        sb.append(str);
        sb.append(&quot;\n&quot;);
    }
    sb.replace(sb.length() - 2,sb.length(),&quot;&quot;);

    switch (requestCode){
        case 0:
            Toast.makeText(this, &quot;已拒绝权限&quot; + perms.get(0), Toast.LENGTH_SHORT).show();
            break;
        case 1:
            Toast.makeText(this, &quot;已拒绝WRITE_EXTERNAL_STORAGE和WRITE_EXTERNAL_STORAGE权限&quot;+ perms.get(0), Toast.LENGTH_SHORT).show();
            break;
    }
    if (EasyPermissions.somePermissionPermanentlyDenied(this, perms)) {
        Toast.makeText(this, &quot;已拒绝权限&quot; + sb + &quot;并不再询问&quot; , Toast.LENGTH_SHORT).show();
        new AppSettingsDialog
                .Builder(this)
                .setRationale(&quot;此功能需要&quot; + sb + &quot;权限，否则无法正常使用，是否打开设置&quot;)
                .setPositiveButton(&quot;是&quot;)
                .setNegativeButton(&quot;否&quot;)
                .build()
                .show();
    }
}
</code></pre>
<h3 id="6-可选afterpermissiongranted注解">6、(可选)@AfterPermissionGranted()注解</h3>
<p>使用 AfterPermissioonGranted 注解。这是可选的，但是提供出来是为了方便。如果所有的请求的权限都被授予了，被注解的方法将会被执行，这样做是为了简化通常的请求权限成功之后再调用方法的流程。同时也可以在onPermissionsGranted 的回调中添加逻辑操作：<br>
比如官网上的这个实例代码：<br>
这里的方法名可以自己取，主要是权限都申请完，就调用这个方法，执行里面的操作。<br>
其实就相当于在onPermissionsGranted()调用这个方法而已:</p>
<pre><code>@AfterPermissionGranted(RC_CAMERA_AND_LOCATION)
private void methodRequiresTwoPermission() {
String[] perms = {Manifest.permission.CAMERA, Manifest.permission.ACCESS_FINE_LOCATION};
if (EasyPermissions.hasPermissions(this, perms)) {
    // Already have permission, do the thing
    // ...
} else {
    // Do not have permissions, request them now
    EasyPermissions.requestPermissions(this, getString(R.string.camera_and_location_rationale),
            RC_CAMERA_AND_LOCATION, perms);
}
}
</code></pre>
<h3 id="4-android-80运行时权限">4、android 8.0运行时权限</h3>
<p>对于针对Android O的应用，此行为已被纠正。系统只会授予应用明确请求的权限。然而一旦用户为应用授予某个权限，则所有后续对该权限组中权限的请求都将被自动批准。</p>
<p>例如，假设某个应用在其清单中列出READ_EXTERNAL_STORAGE和WRITE_EXTERNAL_STORAGE。应用请求READ_EXTERNAL_STORAGE，并且用户授予了该权限，如果该应用针对的是API级别24或更低级别，系统还会同时授予WRITE_EXTERNAL_STORAGE，因为该权限也属于STORAGE权限组并且也在清单中注册过。如果该应用针对的是Android O，则系统此时仅会授予READ_EXTERNAL_STORAGE，不过在该应用以后申请WRITE_EXTERNAL_STORAGE权限时，系统会立即授予该权限，而不会提示用户。<br>
注意：如果使用了没有授权的权限，会崩溃的</p>
<p>所以对于8.0权限，我们要做的处理，是尽量把所用到的危险权限全部申请。但是有的权限在不同版本出现，所以要兼容不同的版本，所以要加一个版本的判断。</p>
<pre><code>归根结底：android M (6.0)以后，申请权限组一个，即表示整个权限组可以用，所以我们干脆，只要api 版本大于23（6.0）,我们申请的权限就是申请整个权限组。这样就兼容了android8.0-------------------为了省事的话可以用AndPermission这个第三方框架，或者自己封装一个。
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[集成gitalk评论]]></title>
        <id>https://galiful.github.io/Resume//post/ji-cheng-gitalk-ping-lun</id>
        <link href="https://galiful.github.io/Resume//post/ji-cheng-gitalk-ping-lun">
        </link>
        <updated>2019-05-20T01:07:25.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<p><a href="https://github.com/gitalk/gitalk/blob/master/readme-cn.md">gitalk</a><br>
存在由于文章标题过长时导致无法初始化（github pages 机制），解决办法在<a href="https://github.com/gitalk/gitalk/issues/124">这</a><br>
<img src="https://galiful.github.io/Resume//post-images/1558314852687.png" alt=""></p>
]]></content>
    </entry>
</feed>